# Temporal C++ SDK

[![MIT](https://img.shields.io/github/license/temporalio/sdk-dotnet.svg?style=for-the-badge)](LICENSE)

[Temporal](https://temporal.io/) is a distributed, scalable, durable, and highly available orchestration engine used to
execute asynchronous, long-running business logic in a scalable and resilient way.

**Temporal C++ SDK** is a C++20 client library for authoring and running Temporal workflows, activities, and Nexus
operations. It wraps the shared Rust `sdk-core` engine via a C FFI bridge, providing fully asynchronous coroutine-based
APIs.

> **Status: Functionally Complete** -- The SDK builds on MSVC 2022 (Windows) with 676/682 unit tests passing.
> All 3 self-contained examples run end-to-end against a live Temporal server with clean shutdown (exit code 0).
> Workflows execute activities, handle signals/queries/updates, use timers, and return results correctly.
> The API is not yet stable.

## Features

- **C++20 coroutines** -- `co_await` / `co_return` for all async operations (workflows, client calls, timers)
- **Lazy `Task<T>`** with symmetric transfer for efficient coroutine chaining
- **Deterministic `CoroutineScheduler`** for workflow replay (single-threaded FIFO, matching the Temporal execution model)
- **Full Temporal API coverage** -- workflows, activities (with `execute_activity()`), signals, queries, updates, child workflows, Nexus operations
- **Type-safe workflow invocation** via template deduction on member function pointers
- **Interceptor chains** for both client-side and worker-side operations
- **Protobuf integration** -- 74 Temporal API proto files auto-generated at build time
- **OpenTelemetry extension** -- tracing interceptor for workflow/activity spans
- **Diagnostics extension** -- metrics adapter for counters, histograms, and gauges

## Prerequisites

- **CMake** 3.20+
- **C++20 compiler**: MSVC 2022+ (Windows), GCC 11+ or Clang 14+ (Linux)
- **Rust toolchain** (`cargo`) -- for building the `sdk-core` C bridge library
- **Git** -- clone recursively to fetch the `sdk-core` submodule

## Quick Start

### Clone

```bash
git clone --recursive https://github.com/temporalio/sdk-dotnet.git temporal-sdk-cpp
cd temporal-sdk-cpp
```

### Build

Dependencies (abseil, protobuf, nlohmann/json, Google Test) are fetched automatically via CMake FetchContent.

```bash
# Configure
cmake -B cpp/build -S cpp

# Build the library
cmake --build cpp/build --target temporalio

# Build and run tests
cmake --build cpp/build --target temporalio_tests
ctest --test-dir cpp/build --output-on-failure
```

To skip optional components:

```bash
cmake -B cpp/build -S cpp \
  -DTEMPORALIO_BUILD_EXTENSIONS=OFF \
  -DTEMPORALIO_BUILD_EXAMPLES=OFF \
  -DTEMPORALIO_BUILD_TESTS=OFF
```

### Usage Example

```cpp
#include <temporalio/client/temporal_client.h>
#include <temporalio/client/temporal_connection.h>
#include <temporalio/worker/temporal_worker.h>
#include <temporalio/workflows/workflow.h>
#include <temporalio/workflows/workflow_definition.h>

using namespace temporalio;

// Activity: takes a name, returns a greeting
temporalio::async_::Task<std::string> greet(std::string name) {
    co_return "Hello, " + name + "!";
}

// Workflow: calls the greet activity and returns its result
class GreetingWorkflow {
public:
    async_::Task<std::any> run(std::vector<std::any> args) {
        auto name = std::any_cast<std::string>(args[0]);
        workflows::ActivityOptions opts;
        opts.start_to_close_timeout = std::chrono::seconds(30);
        co_return co_await workflows::Workflow::execute_activity(
            "greet", std::any(name), opts);
    }
};

int main() {
    // Connect to Temporal
    auto tc = async_::run_task_sync(client::TemporalClient::connect(
        {.connection = {.target_host = "localhost:7233"}}));

    // Register activity and workflow
    auto activity = activities::ActivityDefinition::create("greet", &greet);
    auto workflow = workflows::WorkflowDefinition::create<GreetingWorkflow>(
        "GreetingWorkflow").run(&GreetingWorkflow::run).build();

    // Start worker on a background thread
    worker::TemporalWorkerOptions opts;
    opts.task_queue = "greeting-queue";
    opts.activities.push_back(activity);
    opts.workflows.push_back(workflow);
    worker::TemporalWorker w(tc, opts);

    std::stop_source stop;
    std::jthread worker_thread([&w, token = stop.get_token()]() {
        async_::run_task_sync(w.execute_async(token));
    });

    // Start workflow and get result
    auto handle = async_::run_task_sync(tc->start_workflow(
        "GreetingWorkflow", "\"World\"",
        {.id = "my-workflow", .task_queue = "greeting-queue"}));
    auto result = async_::run_task_sync(handle.get_result());
    std::cout << "Result: " << result << "\n";

    // Clean shutdown on main thread
    stop.request_stop();
    worker_thread.join();
}
```

## Project Structure

```
cpp/
  CMakeLists.txt                    # Top-level CMake build
  vcpkg.json                       # Dependency manifest
  cmake/
    Platform.cmake                 # Platform detection, Rust cargo build
    CompilerWarnings.cmake         # Warning flags
    ProtobufGenerate.cmake         # Proto code generation

  include/temporalio/              # Public headers (34 files)
    async_/                        # Task<T>, CancellationToken, CoroutineScheduler, TaskCompletionSource
    client/                        # TemporalClient, TemporalConnection, WorkflowHandle
      interceptors/                # IClientInterceptor, ClientOutboundInterceptor
    common/                        # RetryPolicy, SearchAttributes, MetricMeter, enums
    converters/                    # DataConverter, IPayloadConverter, IFailureConverter
    exceptions/                    # 20+ exception types (TemporalException hierarchy)
    nexus/                         # NexusServiceDefinition, OperationHandler
    runtime/                       # TemporalRuntime, telemetry config
    testing/                       # WorkflowEnvironment, ActivityEnvironment
    worker/                        # TemporalWorker, WorkflowInstance
      interceptors/                # IWorkerInterceptor, inbound/outbound interceptors
      internal/                    # ActivityWorker, WorkflowWorker, NexusWorker
    workflows/                     # Workflow ambient API, WorkflowDefinition builder, ActivityOptions

  src/temporalio/                  # Private implementation (25 .cpp + 8 .h)
    bridge/                        # Rust FFI wrappers (SafeHandle, CallScope, interop)

  extensions/
    opentelemetry/                 # TracingInterceptor
    diagnostics/                   # CustomMetricMeter

  tests/                           # Google Test suite (37 files, 682 tests)
  examples/                        # 6 examples (see Examples section below)
```

## Examples

Six examples in `cpp/examples/` demonstrate key Temporal patterns. All require a running Temporal server (`temporal server start-dev`).

| Example | What it demonstrates |
|---------|---------------------|
| `hello_world` | Client-only: connect and start a workflow |
| `signal_workflow` | Client-only: send signals and query workflow state |
| `activity_worker` | Worker-only: define and register activities |
| `workflow_activity` | **E2E**: workflow calls `execute_activity()`, returns result, clean shutdown |
| `timer_workflow` | **E2E**: deterministic timers, conditions, signals, queries |
| `update_workflow` | **E2E**: update handlers with validators, queries, signals |

```bash
# Build all examples
cmake --build cpp/build --config Debug

# Run an example (requires: temporal server start-dev)
./cpp/build/examples/Debug/example_workflow_activity
```

## Architecture

```
User Code (C++20)
       |
Public API Layer (Client, Workflows, Activities, Worker, Testing, Converters)
       |
Bridge Layer (SafeHandle + CallScope + FFI wrappers)
       |
Native Library (temporal_sdk_core_c_bridge -- Rust, compiled via cargo)
```

### Key Design Decisions

| Concept | C++ Approach |
|---------|-------------|
| Async/await | C++20 coroutines (`co_await` / `co_return`) with lazy `Task<T>` |
| Deterministic execution | `CoroutineScheduler` (FIFO deque, single-threaded) |
| Cancellation | `std::stop_token` / `std::stop_source` |
| Context propagation | `thread_local` pointers with RAII scopes |
| FFI memory management | `CallScope` (scoped allocations with `std::deque` for stable references) |
| Rust handle ownership | `SafeHandle<T>` RAII template with custom deleters |
| Callback-to-coroutine bridge | `TaskCompletionSource<T>` |
| Type-erased payloads | `std::any` |
| Shared ownership | `std::shared_ptr` (runtime, connection, client) |
| Pimpl pattern | `std::unique_ptr<Impl>` for ABI stability |

## CMake Options

| Option | Default | Description |
|--------|---------|-------------|
| `TEMPORALIO_BUILD_EXTENSIONS` | `ON` | Build OpenTelemetry and Diagnostics extensions |
| `TEMPORALIO_BUILD_TESTS` | `ON` | Build the Google Test suite |
| `TEMPORALIO_BUILD_EXAMPLES` | `ON` | Build example programs |
| `TEMPORALIO_BUILD_PROTOS` | `ON` | Generate C++ types from Temporal API `.proto` files |
| `BUILD_SHARED_LIBS` | `OFF` | Build as shared library instead of static |

## Dependencies

| Library | Purpose | Source |
|---------|---------|--------|
| **Protobuf** v29.3 | Temporal API types, bridge serialization | FetchContent or vcpkg |
| **abseil-cpp** | Required by Protobuf | FetchContent or vcpkg |
| **nlohmann/json** | JSON payload conversion | FetchContent or vcpkg |
| **Google Test** | Unit testing framework | FetchContent or vcpkg |
| **OpenTelemetry C++** | Tracing extension (optional) | vcpkg |
| **Rust toolchain** | Building the `sdk-core` bridge library | Pre-installed |

All dependencies except Rust are fetched automatically via CMake FetchContent if not found on the system.

## Testing

```bash
# Build and run all tests
cmake --build cpp/build --target temporalio_tests
ctest --test-dir cpp/build --output-on-failure

# Run tests with verbose output
ctest --test-dir cpp/build --output-on-failure --verbose
```

682 unit tests (676 passing) cover:
- Async primitives (Task, CancellationToken, CoroutineScheduler, TaskCompletionSource)
- Bridge layer (CallScope, SafeHandle)
- Client (connection options, interceptors, workflow handle)
- Common types (enums, metrics, retry policy, search attributes)
- Converters (data converter, failure converter)
- Exceptions (full hierarchy)
- Nexus (operation handlers)
- Runtime (lifecycle)
- Testing utilities (activity environment, workflow environment)
- Worker (options, interceptors, workflow instance, replayer)
- Workflows (ambient API, definitions, info types)

Set environment variables to test against an external Temporal server:

```bash
export TEMPORAL_TEST_CLIENT_TARGET_HOST="localhost:7233"
export TEMPORAL_TEST_CLIENT_NAMESPACE="default"
```

## Extensions

### OpenTelemetry Tracing

```cpp
#include <temporalio/extensions/opentelemetry/tracing_interceptor.h>

// Add tracing to client and worker
auto tracing = std::make_shared<extensions::opentelemetry::TracingInterceptor>();
client_opts.interceptors.push_back(tracing);
worker_opts.interceptors.push_back(tracing);
```

### Diagnostics Metrics

```cpp
#include <temporalio/extensions/diagnostics/custom_metric_meter.h>

// Adapt Temporal metrics to OpenTelemetry Metrics API
auto meter = std::make_shared<extensions::diagnostics::CustomMetricMeter>(otel_meter);
runtime_opts.metrics.custom_meter = meter;
```

## Ported From

This SDK is a C++20 port of the [Temporal .NET SDK](https://github.com/temporalio/sdk-dotnet). The original C# SDK
(~469 source files, ~412 tests) was systematically converted to idiomatic C++20, replacing:

- C# `async`/`await` with C++20 coroutines
- .NET `Task<T>` with a custom lazy coroutine `Task<T>`
- P/Invoke with direct C FFI calls
- `CancellationToken` with `std::stop_token`
- Reflection-based registration with template-based builders
- xUnit with Google Test

## License

MIT License - see [LICENSE](LICENSE) for details.
