#pragma once

/// @file Per-execution determinism engine implementing custom coroutine scheduler.

#include <any>
#include <chrono>
#include <cstdint>
#include <deque>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <random>
#include <stop_token>
#include <string>
#include <utility>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include <temporalio/async_/cancellation_token.h>
#include <temporalio/async_/coroutine_scheduler.h>
#include <temporalio/async_/task.h>
#include <temporalio/async_/task_completion_source.h>
#include <temporalio/workflows/workflow.h>
#include <temporalio/workflows/workflow_definition.h>
#include <temporalio/workflows/workflow_info.h>

namespace temporalio::worker {

/// Per-execution determinism engine for workflow replay.
///
/// This is the C++ equivalent of the C# WorkflowInstance class which is
/// the single most critical file in the SDK (1000+ lines in C#).
///
/// Manages:
/// - CoroutineScheduler for single-threaded deterministic execution
/// - Activation processing (start, signal, query, update, timer, activity)
/// - Command generation (start timer, schedule activity, start child)
/// - Condition checking
/// - Patch/version support
/// - Pending operation tracking
class WorkflowInstance : public workflows::WorkflowContext {
public:
    /// Command types that can be generated by the workflow.
    enum class CommandType {
        kStartTimer,
        kCancelTimer,
        kScheduleActivity,
        kScheduleLocalActivity,
        kRequestCancelActivity,
        kStartChildWorkflow,
        kCancelChildWorkflow,
        kSignalExternalWorkflow,
        kCancelExternalWorkflow,
        kContinueAsNew,
        kCompleteWorkflow,
        kFailWorkflow,
        kCancelWorkflow,
        kRespondQuery,
        kRespondQueryFailed,
        kSetPatchMarker,
        kUpdateAccepted,
        kUpdateRejected,
        kUpdateCompleted,
        kScheduleNexusOperation,
        kCancelNexusOperation,
    };

    /// Data for a StartTimer command.
    struct StartTimerData {
        uint32_t seq{0};
        std::chrono::milliseconds duration{0};
    };

    /// Data for a CancelTimer command.
    struct CancelTimerData {
        uint32_t seq{0};
    };

    /// Data for a ScheduleActivity command.
    struct ScheduleActivityData {
        uint32_t seq{0};
        std::string activity_type;
        std::string task_queue;
        std::vector<std::any> args;
        std::optional<std::chrono::milliseconds> schedule_to_close_timeout{};
        std::optional<std::chrono::milliseconds> schedule_to_start_timeout{};
        std::optional<std::chrono::milliseconds> start_to_close_timeout{};
        std::optional<std::chrono::milliseconds> heartbeat_timeout{};
        std::optional<common::RetryPolicy> retry_policy{};
        workflows::ActivityCancellationType cancellation_type{
            workflows::ActivityCancellationType::kTryCancel};
        std::optional<std::string> activity_id{};
    };

    /// Data for a RequestCancelActivity command.
    struct RequestCancelActivityData {
        uint32_t seq{0};
    };

    /// Data for query response commands (kRespondQuery / kRespondQueryFailed).
    struct QueryResponseData {
        std::string query_id;
        std::any result;       // For success: the query result
        std::string error;     // For failure: the error message
    };

    /// Data for update response commands (accepted/rejected/completed).
    struct UpdateResponseData {
        std::string protocol_instance_id;
        std::string update_name;
        std::any result;   // For completed: the return value
        std::string error; // For rejected: the error message
    };

    /// Result status for activity/child workflow resolution.
    enum class ResolutionStatus {
        kCompleted,
        kFailed,
        kCancelled,
    };

    /// Data for an activity resolution job (kResolveActivity).
    /// Carries the full result so the caller can inspect success/failure.
    struct ActivityResolution {
        uint32_t seq{0};
        ResolutionStatus status{ResolutionStatus::kCompleted};
        std::any result;       // Completed: decoded payload
        std::string failure;   // Failed/Cancelled: error message
    };

    /// Data for a child workflow resolution job (kResolveChildWorkflow).
    struct ChildWorkflowResolution {
        uint32_t seq{0};
        ResolutionStatus status{ResolutionStatus::kCompleted};
        std::any result;       // Completed: decoded payload
        std::string failure;   // Failed/Cancelled: error message
    };

    /// A command to be sent back to the server.
    struct Command {
        CommandType type;
        uint32_t seq{0};
        std::any data;  // Command-specific payload
    };

    /// Activation job types from the server.
    enum class JobType {
        kStartWorkflow,
        kFireTimer,
        kResolveActivity,
        kResolveChildWorkflow,
        kSignalWorkflow,
        kQueryWorkflow,
        kUpdateWorkflow,
        kCancelWorkflow,
        kResolveSignalExternalWorkflow,
        kResolveRequestCancelExternalWorkflow,
        kNotifyHasPatch,
        kDoUpdate,
        kResolveNexusOperation,
    };

    /// An activation job from the server.
    struct Job {
        JobType type;
        std::any data;  // Job-specific payload
    };

    /// Data for a QueryWorkflow job.
    struct QueryWorkflowData {
        std::string query_id;
        std::string query_name;
        std::vector<std::any> args;
    };

    /// Data for a DoUpdate job.
    struct DoUpdateData {
        std::string id;
        std::string name;
        std::string protocol_instance_id;
        std::vector<std::any> args;
        bool run_validator{false};
    };

    /// Configuration for creating a WorkflowInstance.
    struct Config {
        std::shared_ptr<workflows::WorkflowDefinition> definition;
        workflows::WorkflowInfo info;
        uint64_t randomness_seed{0};
    };

    /// Metadata from the activation envelope (set before processing jobs).
    struct ActivationMetadata {
        std::chrono::system_clock::time_point timestamp{};
        bool is_replaying{false};
        int history_length{0};
        uint64_t history_size_bytes{0};
        bool continue_as_new_suggested{false};
    };

    explicit WorkflowInstance(Config config);
    ~WorkflowInstance() override;

    // Non-copyable, non-movable
    WorkflowInstance(const WorkflowInstance&) = delete;
    WorkflowInstance& operator=(const WorkflowInstance&) = delete;

    /// Process an activation (list of jobs) and return commands.
    /// This is the main entry point called by the WorkflowWorker.
    std::vector<Command> activate(const std::vector<Job>& jobs);

    /// Process an activation with metadata from the activation envelope.
    std::vector<Command> activate(const std::vector<Job>& jobs,
                                  const ActivationMetadata& metadata);

    // -- WorkflowContext interface --
    const workflows::WorkflowInfo& info() const override { return info_; }
    std::stop_token cancellation_token() const override;
    bool continue_as_new_suggested() const override {
        return continue_as_new_suggested_;
    }
    bool all_handlers_finished() const override;
    std::chrono::system_clock::time_point utc_now() const override {
        return current_time_;
    }
    std::mt19937& random() override { return random_; }
    int current_history_length() const override {
        return current_history_length_;
    }
    int current_history_size() const override { return current_history_size_; }
    bool is_replaying() const override { return is_replaying_; }
    const workflows::WorkflowUpdateInfo* current_update_info() const override;
    bool patched(const std::string& patch_id) override;
    void deprecate_patch(const std::string& patch_id) override;
    async_::Task<void> start_timer(
        std::chrono::milliseconds duration,
        std::stop_token ct) override;
    async_::Task<bool> register_condition(
        std::function<bool()> condition,
        std::optional<std::chrono::milliseconds> timeout,
        std::stop_token ct) override;
    async_::Task<std::any> schedule_activity(
        const std::string& activity_type,
        std::vector<std::any> args,
        const workflows::ActivityOptions& options) override;

    /// Get pending commands to send to the server.
    const std::vector<Command>& pending_commands() const noexcept {
        return commands_;
    }

private:
    /// Run the scheduler until all queued coroutines complete, then check
    /// conditions. Mirrors C# RunOnce().
    void run_once(bool check_conditions);

    /// Initialize the workflow (create instance and start the run coroutine).
    /// Called AFTER all jobs are applied in modern event loop mode.
    void initialize_workflow();

    // Job handlers
    void handle_start_workflow(const Job& job);
    void handle_fire_timer(const Job& job);
    void handle_resolve_activity(const Job& job);
    void handle_resolve_child_workflow(const Job& job);
    void handle_signal_workflow(const Job& job);
    void handle_query_workflow(const Job& job);
    void handle_cancel_workflow(const Job& job);
    void handle_do_update(const Job& job);
    void handle_resolve_signal_external_workflow(const Job& job);
    void handle_resolve_request_cancel_external_workflow(const Job& job);
    void handle_notify_has_patch(const Job& job);
    void handle_resolve_nexus_operation(const Job& job);

    /// Wraps a top-level coroutine invocation, catching workflow exceptions
    /// and converting them to commands (ContinueAsNew, Fail, Cancel).
    /// Mirrors C# WorkflowInstance.RunTopLevelAsync().
    /// @param is_handler If true, decrements in_progress_handler_count_ on
    ///   completion (used for signal/update handlers, not the main workflow run).
    async_::Task<std::any> run_top_level(
        std::function<async_::Task<std::any>(void*, std::vector<std::any>)> func,
        void* instance, std::vector<std::any> args, bool is_handler);

    /// Create a ResumeCallback that routes coroutine resumption through the
    /// scheduler. When a TCS completes, instead of resuming the awaiting
    /// coroutine inline, the handle is enqueued to the scheduler. This
    /// ensures deterministic execution order controlled by the scheduler.
    ///
    /// Uses schedule() (not schedule_from_external()) because all TCS
    /// completions within the WorkflowInstance happen on the workflow thread
    /// during activate(). If external-thread completion is ever needed,
    /// use schedule_from_external() instead.
    async_::ResumeCallback make_resume_callback();

    // -- State --
    std::shared_ptr<workflows::WorkflowDefinition> definition_;
    workflows::WorkflowInfo info_;
    async_::CoroutineScheduler scheduler_;
    async_::CancellationTokenSource cancellation_source_;
    std::mt19937 random_;

    // Instance of the workflow class
    std::shared_ptr<void> instance_;

    // Running coroutine tasks (kept alive to prevent UAF when scheduler
    // holds coroutine handles from these tasks).
    std::vector<async_::Task<std::any>> running_tasks_;

    // Pending operations
    std::unordered_map<uint32_t,
                       std::shared_ptr<async_::TaskCompletionSource<std::any>>>
        pending_timers_;
    std::unordered_map<uint32_t,
                       std::shared_ptr<async_::TaskCompletionSource<std::any>>>
        pending_activities_;
    std::unordered_map<uint32_t,
                       std::shared_ptr<async_::TaskCompletionSource<std::any>>>
        pending_child_workflows_;
    std::unordered_map<uint32_t,
                       std::shared_ptr<async_::TaskCompletionSource<std::any>>>
        pending_external_signals_;
    std::unordered_map<uint32_t,
                       std::shared_ptr<async_::TaskCompletionSource<std::any>>>
        pending_external_cancels_;
    std::unordered_map<uint32_t,
                       std::shared_ptr<async_::TaskCompletionSource<std::any>>>
        pending_nexus_operations_;

    // Conditions waiting to be checked
    std::deque<
        std::pair<std::function<bool()>,
                  std::shared_ptr<async_::TaskCompletionSource<bool>>>>
        conditions_;

    // Timeout timer seq -> condition TCS mapping.
    // When a wait_condition has a timeout, we create a timer. When that timer
    // fires, we resolve the associated condition TCS with false.
    std::unordered_map<uint32_t,
                       std::shared_ptr<async_::TaskCompletionSource<bool>>>
        timeout_to_condition_;

    // Reverse mapping: condition TCS address -> timeout timer seq.
    // Used when a condition is met to cancel its associated timeout timer.
    std::unordered_map<void*, uint32_t> condition_to_timeout_;

    // Patches
    std::unordered_set<std::string> patches_notified_;
    std::unordered_map<std::string, bool> patches_memoized_;

    // Commands to emit
    std::vector<Command> commands_;

    // Counters
    uint32_t timer_counter_{0};
    uint32_t activity_counter_{0};
    uint32_t child_workflow_counter_{0};
    uint32_t external_signal_counter_{0};
    uint32_t external_cancel_counter_{0};
    uint32_t nexus_operation_counter_{0};

    // Activation state
    std::chrono::system_clock::time_point current_time_;
    int current_history_length_{0};
    int current_history_size_{0};
    bool is_replaying_{false};
    bool continue_as_new_suggested_{false};
    bool workflow_started_{false};
    bool workflow_initialized_{false};
    std::exception_ptr current_activation_exception_;

    // In-progress handler count
    int in_progress_handler_count_{0};

    // Update info (only valid during update handling)
    std::optional<workflows::WorkflowUpdateInfo> current_update_info_;
};

}  // namespace temporalio::worker

