#pragma once

/// @file Per-execution determinism engine implementing custom coroutine scheduler.

#include <any>
#include <chrono>
#include <cstdint>
#include <deque>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <random>
#include <stop_token>
#include <string>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include <temporalio/async_/cancellation_token.h>
#include <temporalio/async_/coroutine_scheduler.h>
#include <temporalio/async_/task.h>
#include <temporalio/async_/task_completion_source.h>
#include <temporalio/workflows/workflow.h>
#include <temporalio/workflows/workflow_definition.h>
#include <temporalio/workflows/workflow_info.h>

namespace temporalio::worker {

/// Per-execution determinism engine for workflow replay.
///
/// This is the C++ equivalent of the C# WorkflowInstance class which is
/// the single most critical file in the SDK (1000+ lines in C#).
///
/// Manages:
/// - CoroutineScheduler for single-threaded deterministic execution
/// - Activation processing (start, signal, query, update, timer, activity)
/// - Command generation (start timer, schedule activity, start child)
/// - Condition checking
/// - Patch/version support
/// - Pending operation tracking
class WorkflowInstance : public workflows::WorkflowContext {
public:
    /// Command types that can be generated by the workflow.
    enum class CommandType {
        kStartTimer,
        kCancelTimer,
        kScheduleActivity,
        kScheduleLocalActivity,
        kRequestCancelActivity,
        kStartChildWorkflow,
        kCancelChildWorkflow,
        kSignalExternalWorkflow,
        kCancelExternalWorkflow,
        kContinueAsNew,
        kCompleteWorkflow,
        kFailWorkflow,
        kCancelWorkflow,
        kRespondQuery,
        kSetPatchMarker,
    };

    /// A command to be sent back to the server.
    struct Command {
        CommandType type;
        uint32_t seq{0};
        std::any data;  // Command-specific payload
    };

    /// Activation job types from the server.
    enum class JobType {
        kStartWorkflow,
        kFireTimer,
        kResolveActivity,
        kResolveChildWorkflow,
        kSignalWorkflow,
        kQueryWorkflow,
        kUpdateWorkflow,
        kCancelWorkflow,
        kResolveSignalExternalWorkflow,
        kResolveRequestCancelExternalWorkflow,
        kNotifyHasPatch,
        kDoUpdate,
        kResolveNexusOperation,
    };

    /// An activation job from the server.
    struct Job {
        JobType type;
        std::any data;  // Job-specific payload
    };

    /// Configuration for creating a WorkflowInstance.
    struct Config {
        std::shared_ptr<workflows::WorkflowDefinition> definition;
        workflows::WorkflowInfo info;
        uint64_t randomness_seed{0};
    };

    explicit WorkflowInstance(Config config);
    ~WorkflowInstance() override;

    // Non-copyable, non-movable
    WorkflowInstance(const WorkflowInstance&) = delete;
    WorkflowInstance& operator=(const WorkflowInstance&) = delete;

    /// Process an activation (list of jobs) and return commands.
    /// This is the main entry point called by the WorkflowWorker.
    std::vector<Command> activate(const std::vector<Job>& jobs);

    // -- WorkflowContext interface --
    const workflows::WorkflowInfo& info() const override { return info_; }
    std::stop_token cancellation_token() const override;
    bool continue_as_new_suggested() const override {
        return continue_as_new_suggested_;
    }
    bool all_handlers_finished() const override;
    std::chrono::system_clock::time_point utc_now() const override {
        return current_time_;
    }
    std::mt19937& random() override { return random_; }
    int current_history_length() const override {
        return current_history_length_;
    }
    int current_history_size() const override { return current_history_size_; }
    bool is_replaying() const override { return is_replaying_; }
    const workflows::WorkflowUpdateInfo* current_update_info() const override;
    bool patched(const std::string& patch_id) override;
    void deprecate_patch(const std::string& patch_id) override;

    /// Get pending commands to send to the server.
    const std::vector<Command>& pending_commands() const noexcept {
        return commands_;
    }

private:
    /// Run the scheduler until all queued coroutines complete, then check
    /// conditions. Mirrors C# RunOnce().
    void run_once(bool check_conditions);

    /// Initialize the workflow (create instance and start the run coroutine).
    /// Called AFTER all jobs are applied in modern event loop mode.
    void initialize_workflow();

    // Job handlers
    void handle_start_workflow(const Job& job);
    void handle_fire_timer(const Job& job);
    void handle_resolve_activity(const Job& job);
    void handle_resolve_child_workflow(const Job& job);
    void handle_signal_workflow(const Job& job);
    void handle_query_workflow(const Job& job);
    void handle_cancel_workflow(const Job& job);
    void handle_do_update(const Job& job);
    void handle_resolve_signal_external_workflow(const Job& job);
    void handle_resolve_request_cancel_external_workflow(const Job& job);
    void handle_notify_has_patch(const Job& job);
    void handle_resolve_nexus_operation(const Job& job);

    /// Wraps a top-level coroutine invocation, catching workflow exceptions
    /// and converting them to commands (ContinueAsNew, Fail, Cancel).
    /// Mirrors C# WorkflowInstance.RunTopLevelAsync().
    /// @param is_handler If true, decrements in_progress_handler_count_ on
    ///   completion (used for signal/update handlers, not the main workflow run).
    async_::Task<std::any> run_top_level(
        std::function<async_::Task<std::any>(void*, std::vector<std::any>)> func,
        void* instance, std::vector<std::any> args, bool is_handler);

    // -- State --
    std::shared_ptr<workflows::WorkflowDefinition> definition_;
    workflows::WorkflowInfo info_;
    async_::CoroutineScheduler scheduler_;
    async_::CancellationTokenSource cancellation_source_;
    std::mt19937 random_;

    // Instance of the workflow class
    std::shared_ptr<void> instance_;

    // Running coroutine tasks (kept alive to prevent UAF when scheduler
    // holds coroutine handles from these tasks).
    std::vector<async_::Task<std::any>> running_tasks_;

    // Pending operations
    std::unordered_map<uint32_t,
                       std::shared_ptr<async_::TaskCompletionSource<std::any>>>
        pending_timers_;
    std::unordered_map<uint32_t,
                       std::shared_ptr<async_::TaskCompletionSource<std::any>>>
        pending_activities_;
    std::unordered_map<uint32_t,
                       std::shared_ptr<async_::TaskCompletionSource<std::any>>>
        pending_child_workflows_;

    // Conditions waiting to be checked
    std::deque<
        std::tuple<std::function<bool()>,
                   std::shared_ptr<async_::TaskCompletionSource<bool>>>>
        conditions_;

    // Patches
    std::unordered_set<std::string> patches_notified_;
    std::unordered_map<std::string, bool> patches_memoized_;

    // Commands to emit
    std::vector<Command> commands_;

    // Counters
    uint32_t timer_counter_{0};
    uint32_t activity_counter_{0};
    uint32_t child_workflow_counter_{0};

    // Activation state
    std::chrono::system_clock::time_point current_time_;
    int current_history_length_{0};
    int current_history_size_{0};
    bool is_replaying_{false};
    bool continue_as_new_suggested_{false};
    bool workflow_started_{false};
    bool workflow_initialized_{false};
    std::exception_ptr current_activation_exception_;

    // In-progress handler count
    int in_progress_handler_count_{0};

    // Update info (only valid during update handling)
    std::optional<workflows::WorkflowUpdateInfo> current_update_info_;
};

}  // namespace temporalio::worker

